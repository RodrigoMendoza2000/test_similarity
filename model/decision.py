# ---------------------------------------------------------------
# Decision class
# Authors: Diego Yunoe Sierra Díaz
#          Rodrigo Alfredo Mendoza España
# Last modified: 20/04/2024
# ---------------------------------------------------------------

import pandas as pd
from model.plagiarism_type import identify_text_change
from fpdf import FPDF


def get_auc(par_confusion_matrix: dict) -> float:
    """
    Calculate the Area Under the Curve (AUC) for the given confusion matrix.

    Args:
        par_confusion_matrix (dict): A dictionary representing the confusion
        matrix.

    Returns:
        float: The Area Under the Curve (AUC) calculated from the confusion
        matrix.
    """
    true_positive = par_confusion_matrix['true_positive']
    false_positive = par_confusion_matrix['false_positive']
    true_negative = par_confusion_matrix['true_negative']
    false_negative = par_confusion_matrix['false_negative']

    tpr = true_positive / (true_positive + false_negative)
    fpr = false_positive / (false_positive + true_negative)

    auc = (1 + tpr - fpr) / 2

    return auc


def generate_pdf(title: str,
                 plagiarism_percent: float,
                 text: str,
                 file_name: str) -> None:
    """
    Generate a PDF file with the given title,
    plagiarism percentage, text, and file name.

    :param title: Whether it was detected plagiarism or not
    :param plagiarism_percent: The percentage of plagiarism in the text
    :param text: All the text to be generated in the pdf such as sentences
    and where they plagiarized those sentences
    :param file_name: The name of the file to be generated
    :return: None
    """
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    pdf.cell(200, 10, txt=f"File name: {file_name}",
             ln=True, align="C")
    pdf.cell(200, 10, txt=f"Result: {title}",
             ln=True, align="C")
    pdf.cell(200, 10, txt=f"Plagiarism Detected: "
                          f"{plagiarism_percent * 100:.2f}%",
             ln=True, align="C")
    pdf.ln(5)
    pdf.set_font("Arial")
    pdf.multi_cell(0, 10, txt=text, border=0, align="L")

    pdf.output('./results/' + file_name + "_results.pdf")


def read_file(file_path: str) -> str:
    """
    Read the content of a file.

    Args:
        file_path (str): The path of the file to read.

    Returns:
        str: The content of the file.
    """
    with open(file_path, 'r', encoding='ISO-8859-1') as file:
        return file.read()


class Decision:
    """
        A class to perform decision making based on plagiarism analysis.

        Attributes:
            cosine_similarity_threshhold (float): Threshold for
                cosine similarity.
            plagiarism_percentage_threshhold (float): Threshold for
                        plagiarism percentage. A document will be considered
                        plagiarized if the percentage of plagiarized content
                        is greater than this threshold.
        """

    def __init__(self,
                 cosine_similarity_threshhold=0.7,
                 plagiarism_percentage_threshhold=0.35,
                 document_cosine_similarity_threshhold=0.4):
        self.document_cosine_similarity_threshhold = \
            document_cosine_similarity_threshhold
        self.cosine_similarity_threshhold = cosine_similarity_threshhold
        self.plagiarism_percentage_threshhold = \
            plagiarism_percentage_threshhold

    def get_plagiarism_sentences(self,
                                 processed_list: list,
                                 most_similar_documents: dict = {}) -> dict:
        """
        Generate a plagiarism report based on processed sentences. This report
        will be converted to pdf using the generate_pdf function.

        :param processed_list: the list generated by using the
        get_most_similar_document_sentences method from Processing class
        :param most_similar_documents: the dictionary generated by using the
        get_most_similar_documents method from Processing class
        :return: a dictionary with the following format
        {'title': PLAGIARISM DETECTED / PLAGIARISM NOT DETECTED,
        'plagiarism_percent': the percentage of plagiarism in the text,
        'text': the text to be displayed in the pdf}
        """

        result = {}
        display_text = ""
        df = pd.DataFrame(processed_list, columns=['sentence',
                                                   'cosine_score',
                                                   'file_name',
                                                   'file_sentence_number',
                                                   'similar_sentence'])

        display_text += 'Text to analyze: '
        for index, row in df.iterrows():
            display_text += row['sentence'] + ' '

        display_text += '\n\n'
        # df = df.drop(df[df.cosine_score < self.cosine_similarity_threshhold]
        #              .index)

        if self.is_plagiarism(
                self.get_plagiarism_pct_sentences(processed_list)):
            result['title'] = "PLAGIARISM DETECTED\n\n"
        else:
            result['title'] = "PLAGIARISM NOT DETECTED\n\n"

        for index, row in df.iterrows():
            if row['cosine_score'] < self.cosine_similarity_threshhold:
                display_text += f"Sentence: " \
                                f"The following sentence: " \
                                f"'{row['sentence']}' " \
                                f"does not " \
                                f"present plagiarism\n\n "
            else:
                display_text += f"Plagiarized Sentence: The following " \
                                f"sentence: ' {row['sentence']}' " \
                                f"presents plagiarism from  " \
                                f"the '{row['file_name']}' file and" \
                                f" sentence " \
                                f"'{row['similar_sentence']}'\n\n "

        result['plagiarism_percent'] = self.get_plagiarism_pct_sentences(
            processed_list)

        if most_similar_documents != {}:
            display_text += 'Most similar document(s): \n'
        for document, similarity in most_similar_documents.items():
            if similarity > self.cosine_similarity_threshhold:
                display_text += f"{document} " \
                                f"with similarity: " \
                                f"{round(similarity, 2)*100}%\n"

        result['text'] = display_text

        return result

    def get_plagiarism_pct_sentences(self,
                                     processed_list: list
                                     ) -> int:
        """
        Calculate the percentage of plagiarism in a list of
            processed sentences.

        Args:
            processed_list (list): A list containing processed sentences.

        Returns:
            float: Percentage of plagiarism detected in the list.
                The formula for this percentage is:
                plagiarism_percentage = SUM((sentence_length * cosine_score) /
                    document_word_count)
        """
        paragraph_length = 0
        plagiarism_percentage = 0
        for sentence in processed_list:
            if sentence is not None:
                original_sentence = sentence[0]
                paragraph_length += len(original_sentence)

        for sentence in processed_list:

            if sentence is not None:
                original_sentence = sentence[0]
                cosine_score = sentence[1]

                sentence_length = len(original_sentence)
                if cosine_score > self.cosine_similarity_threshhold:
                    plagiarism_percentage += (sentence_length * cosine_score) \
                                             / paragraph_length

        return plagiarism_percentage

    def plagiarism_report_documents(self, doc2vec_documents) -> pd.DataFrame:
        suspicious_documents = []
        plagiarism_type = []
        similar_document = []
        percentage_plagiarism = []
        copy = []

        for file_name, original_documents in doc2vec_documents.items():
            for original_file, cosine_similarity in original_documents.items():
                if cosine_similarity > \
                        self.document_cosine_similarity_threshhold:
                    suspicious_documents.append(file_name)
                    plagiarism_type.append(identify_text_change(
                        read_file('./training_data/' + original_file),
                        read_file('./test_data/' + file_name),
                        cosine_similarity))
                    # plagiarism_type.append('')
                    similar_document.append(original_file)
                    copy.append('Si')
                    percentage_plagiarism.append(cosine_similarity)

            if file_name not in suspicious_documents:
                suspicious_documents.append(file_name)
                plagiarism_type.append('')
                similar_document.append('')
                copy.append('No')
                percentage_plagiarism.append(None)

        dictionary = {'Documento sospechoso': suspicious_documents,
                      'Copia': copy,
                      'Documento Plagiado': similar_document,
                      '% plagio': percentage_plagiarism,
                      'Tipo de plagio': plagiarism_type}

        df = pd.DataFrame(dictionary)

        return df

    def is_plagiarism(self, plagiarism_percentage: float) -> bool:
        """
        Check if the given plagiarism percentage exceeds the threshold.

        Args:
            plagiarism_percentage (float): Percentage of plagiarism.

        Returns:
            bool: True if plagiarism percentage exceeds the threshold,
                False otherwise.
        """
        return plagiarism_percentage > self.plagiarism_percentage_threshhold

    def get_confusion_matrix(self,
                             processed_files: dict,
                             original_files: dict) -> dict:
        """
        Generate a confusion matrix based on processed and original files.

        Args:
            processed_files (dict): A dictionary containing processed files.
                This processed files may be obtained from Processing
                class, get_training_results() method.
            original_files (dict): A dictionary containing original files.

        Returns:
            dict: A dictionary representing the confusion matrix.
        """
        true_positive = 0
        false_positive = 0
        true_negative = 0
        false_negative = 0

        for file_name, processed_list in processed_files.items():
            plagiarism_percentage = self.get_plagiarism_pct_sentences(
                processed_list
            )
            if original_files[file_name] is True:
                if self.is_plagiarism(plagiarism_percentage):
                    true_positive += 1
                else:
                    false_negative += 1
            else:
                if self.is_plagiarism(plagiarism_percentage):
                    false_positive += 1
                else:
                    true_negative += 1

        return {'true_positive': true_positive,
                'false_positive': false_positive,
                'true_negative': true_negative,
                'false_negative': false_negative}


if __name__ == "__main__":
    from processing import Processing

    doc2vec = Processing(training_directory='../training_data',
                         test_directory='../test_data',
                         document_or_sentences='sentences',
                         lemmatize_or_stemming='lemmatize')
    doc2vec.train_model()

    doc2vecdocuments = Processing(training_directory='../training_data',
                                  test_directory='../test_data',
                                  document_or_sentences='document',
                                  lemmatize_or_stemming='lemmatize')
    doc2vecdocuments.train_model()

    top = doc2vecdocuments.get_most_similar_documents(
        '../test_data/FID-08.txt')

    lst = doc2vec.get_most_similar_document_sentences(
        '../test_data/FID-08.txt')

    decision = Decision()
    print(decision.get_plagiarism_sentences(lst, top))
    print(decision.get_plagiarism_pct_sentences(lst))

    # for i in range(1, 11):
    #     doc = f'../test_data/FID-{i:02}.txt'
    #     lst = doc2vec.get_most_similar_document_sentences(doc)
    #     print(doc, decision.get_plagiarism_pct_sentences(lst))

    """training_dat = doc2vec.testing_data()

    dic = {
        'FID-01.txt': True,
        'FID-02.txt': True,
        'FID-03.txt': True,
        'FID-04.txt': True,
        'FID-05.txt': True,
        'FID-06.txt': True,
        'FID-07.txt': True,
        'FID-08.txt': True,
        'FID-09.txt': True,
        'FID-10.txt': True,
        'FID-11-mine.txt': False,
    }

    
    confusion_matrix = decision.get_confusion_matrix(training_dat, dic)

    print(get_auc(confusion_matrix))"""

    #
    # print(decision.get_plagiarism_pct_sentences(lst))
